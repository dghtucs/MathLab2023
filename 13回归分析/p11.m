1.% 原子对序号和相应距离的数据
2.data = [4,1,0.9607;
3.12,1,0.4399;
4.13,1,0.8143;
5.17,1,1.3766;
6.25,2,0.6893;
7.5,3,0.9488;
8.20,3,0.8;
9.21,3,1.109;
10.24,3,1.1432;
11.5,4,0.4758;
12.12,4,1.3402;
13.24,4,0.7006;
14.8,6,0.4945;
15.13,6,1.0559;
16.19,6,0.681;
17.25,6,0.3587;
18.8,7,0.3351;
19.14,7,0.2878;
20.16,7,1.1346;
21.20,7,0.3870;
22.21,7,0.7511;
23.14,8,0.4439;
24.18,8,0.8363;
25.13,9,0.3208;
26.15,9,0.1574;
27.22,9,1.2736;
28.11,10,0.5781;
29.13,10,0.9254;
30.19,10,0.6401;
31.20,10,0.2467;
32.22,10,0.4727;
33.18,11,1.3840;
34.25,11,0.4366;
35.15,12,1.0307;
36.17,12,1.3904;
37.15,13,0.5725;
38.19,13,0.766;
39.15,14,0.4394;
40.16,14,1.0952;
41.20,16,1.0422;
42.23,16,1.8255;
43.18,17,1.4325;
44.19,17,1.0851;
45.20,19,0.4995;
46.23,19,1.2277;
47.24,19,1.1271;
48.23,21,0.706;
49.23,22,0.8052];
50.
51.% 设定原子数量和初始位置
52.num_atoms = 25;
53.positions = zeros(num_atoms, 2);
54.
55.% 生成随机的初始位置
56.for i = 1:num_atoms
57.    positions(i, :) = rand(1, 2) * 10;
58.end
59.
60.% 遗传算法参数设定
61.num_generations = 1000;
62.population_size = 100;
63.mutation_rate = 0.05;
64.selection_size = 20;
65.crossover_rate = 0.7;
66.
67.% 运行遗传算法
68.[best_positions, best_error] = ga_optimization(data, positions, num_generations, population_size, mutation_rate, selection_size, crossover_rate);
69.
70.% 输出结果
71.disp('最优原子位置:')
72.disp(best_positions)
73.disp('最小误差:')
74.disp(best_error)